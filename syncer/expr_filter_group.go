package syncer

import (
	"fmt"

	"github.com/pingcap/tidb-tools/pkg/dbutil"
	"github.com/pingcap/tidb/util/chunk"
	"go.uber.org/zap"

	"github.com/pingcap/dm/dm/config"
	"github.com/pingcap/dm/pkg/log"
	"github.com/pingcap/dm/pkg/utils"
)

// ExprFilterGroup groups many related fields about expression filter.
type ExprFilterGroup struct {
	Configs        map[string][]*config.ExpressionFilter // tableName -> raw config
	InsertExprs    map[string][]*config.Expression       // tableName -> expr
	UpdateOldExprs map[string][]*config.Expression       // tableName -> expr
	UpdateNewExprs map[string][]*config.Expression       // tableName -> expr
	DeleteExprs    map[string][]*config.Expression       // tableName -> expr
}

// NewExprFilterGroup creates a ExprFilterGroup, its Configs has been built.
func NewExprFilterGroup(exprConfig []*config.ExpressionFilter) *ExprFilterGroup {
	ret := &ExprFilterGroup{
		Configs:        map[string][]*config.ExpressionFilter{},
		InsertExprs:    map[string][]*config.Expression{},
		UpdateOldExprs: map[string][]*config.Expression{},
		UpdateNewExprs: map[string][]*config.Expression{},
		DeleteExprs:    map[string][]*config.Expression{},
	}
	for _, c := range exprConfig {
		tableName := dbutil.TableName(c.Schema, c.Table)
		ret.Configs[tableName] = append(ret.Configs[tableName], c)
	}
	return ret
}

// RefreshExprs fills some fields of ExprFilterGroup with expressions, which generated by g.Config and genFunc.
func (g *ExprFilterGroup) RefreshExprs(
	db, table string,
	genFunc func(db, table, expr string) (*config.Expression, error),
	dmlType opType,
) error {
	// TODO: if table doesn't have that column, we should return no error and an expression that skip nothing
	key := dbutil.TableName(db, table)
	switch dmlType {
	case insert:
		for _, c := range g.Configs[key] {
			if c.InsertValueExpr != "" {
				expr, err2 := genFunc(db, table, c.InsertValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.InsertExprs[key] = append(g.InsertExprs[key], expr)
			}
		}
	case update:
		for _, c := range g.Configs[key] {
			if c.UpdateOldValueExpr != "" {
				expr, err2 := genFunc(db, table, c.UpdateOldValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.UpdateOldExprs[key] = append(g.UpdateOldExprs[key], expr)
			} else if c.UpdateNewValueExpr != "" {
				expr, err2 := genFunc(db, table, c.UpdateNewValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.UpdateNewExprs[key] = append(g.UpdateNewExprs[key], expr)
			}
		}
	case del:
		for _, c := range g.Configs[key] {
			if c.DeleteValueExpr != "" {
				expr, err2 := genFunc(db, table, c.DeleteValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.DeleteExprs[key] = append(g.DeleteExprs[key], expr)
			}
		}
	default:
		return fmt.Errorf("unsupported dml job type %s", dmlType)
	}
	return nil
}

// ResetExprs deletes the expressions generated before. This should be called after table structure changed.
func (g *ExprFilterGroup) ResetExprs(db, table string) {
	key := dbutil.TableName(db, table)
	delete(g.InsertExprs, key)
	delete(g.UpdateOldExprs, key)
	delete(g.UpdateNewExprs, key)
	delete(g.DeleteExprs, key)
}

// SkipDMLByExpression returns true when given row matches the expr, which means this row should be skipped.
func SkipDMLByExpression(row []interface{}, expr *config.Expression) (bool, error) {
	log.L().Debug("will evaluate the expression", zap.Stringer("expression", expr), zap.Any("raw row", row))
	// TODO: remove generated columns
	datums, err := utils.AdjustBinaryProtocolForDatum(row, expr.TableInfo.Columns, expr.Session)
	if err != nil {
		return false, err
	}
	r := chunk.MutRowFromDatums(datums).ToRow()

	d, err := expr.Eval(r)
	if err != nil {
		return false, err
	}
	return d.GetInt64() == 1, nil
}
