package syncer

import (
	"fmt"

	"github.com/pingcap/tidb-tools/pkg/dbutil"
	"github.com/pingcap/tidb/expression"
	"github.com/pingcap/tidb/util/chunk"

	"github.com/pingcap/dm/dm/config"
)

type ExprFilterGroup struct {
	Configs map[string][]*config.ExpressionFilter // tableName -> raw config
	InsertExprs map[string][]expression.Expression // tableName -> expr
	UpdateOldExprs map[string][]expression.Expression // tableName -> expr
	UpdateNewExprs map[string][]expression.Expression // tableName -> expr
	DeleteExprs map[string][]expression.Expression // tableName -> expr
}

// NewExprFilterGroup creates a ExprFilterGroup, its Configs has been built.
func NewExprFilterGroup(exprConfig []*config.ExpressionFilter) *ExprFilterGroup {
	ret := &ExprFilterGroup{
		Configs: map[string][]*config.ExpressionFilter{},
		InsertExprs: map[string][]expression.Expression{},
		UpdateOldExprs: map[string][]expression.Expression{},
		UpdateNewExprs: map[string][]expression.Expression{},
		DeleteExprs: map[string][]expression.Expression{},
	}
	for _, c := range exprConfig {
		tableName := dbutil.TableName(c.Schema, c.Table)
		ret.Configs[tableName] = append(ret.Configs[tableName], c)
	}
	return ret
}

// RefreshExprs fills some fields of ExprFilterGroup with expressions, which generated by g.Config and genFunc.
func (g *ExprFilterGroup) RefreshExprs(
	db, table string,
	genFunc func(db, table, expr string) (expression.Expression, error),
	dmlType opType,
) error {
	key := dbutil.TableName(db, table)
	switch dmlType {
	case insert:
		for _, c := range g.Configs[key] {
			if c.InsertValueExpr != "" {
				expr, err2 := genFunc(db, table, c.InsertValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.InsertExprs[key] = append(g.InsertExprs[key], expr)
			}
		}
	case update:
		for _, c := range g.Configs[key] {
			if c.UpdateOldValueExpr != "" {
				expr, err2 := genFunc(db, table, c.UpdateOldValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.UpdateOldExprs[key] = append(g.UpdateOldExprs[key], expr)
			} else if c.UpdateNewValueExpr != "" {
				expr, err2 := genFunc(db, table, c.UpdateNewValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.UpdateNewExprs[key] = append(g.UpdateNewExprs[key], expr)
			}
		}
	case del:
		for _, c := range g.Configs[key] {
			if c.DeleteValueExpr != "" {
				expr, err2 := genFunc(db, table, c.DeleteValueExpr)
				if err2 != nil {
					// TODO: terror
					return err2
				}
				g.DeleteExprs[key] = append(g.DeleteExprs[key], expr)
			}
		}
	default:
		return fmt.Errorf("unsupported dml job type %s", dmlType)
	}
	return nil
}

// SkipDMLByExpression returns true when given row matches the expr, which means this row should be skipped.
func SkipDMLByExpression(row []interface{}, expr expression.Expression) (bool, error) {
	r := chunk.MutRowFromValues(row...).ToRow()
	d, err := expr.Eval(r)
	if err != nil {
		return false, err
	}
	return d.GetInt64() == 1, nil
}